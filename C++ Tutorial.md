# C++


## Header Files
C++ programs are built in a two-stage process. First, each source file is compiled on its own. The compiler generates intermediate files for each compiled source file. These intermediate files are often called object files -- but they are not to be confused with objects in your code. Once all the files have been individually compiled, it then links all the object files together, which generates the final binary (the program). This is where header files come in. Header files allow you to make the declaration visible to other .cpp files, while keeping the definition in its own .cpp file.

## Reference
A reference variable is a "reference" to an existing variable, and it is created with the `&` operator.
```C++
string food = "Pizza";
string& meal = food;

std::cout << food << std::endl;  // Outputs Pizza
std::cout << meal << std::endl;  // Outputs Pizza
```
When a variable is created in C++, a memory address is assigned to the variable. And when we assign a value to the variable, it is stored in this memory address. To access it, use the `&` operator, and the result will represent where the variable is stored:
```C++
string food = "Pizza";

std::cout << &food; // Outputs 0x6dfed4
```


## Pointers
When a variable is created in C++, a memory address is assigned to the variable. And when we assign a value to the variable, it is stored in this memory address. A pointer, however, is a variable that stores the memory address as its value. A pointer variable points to a data type (like int or string) of the same type and is created with the `*` operator. The address of the variable you're working with is assigned to the pointer. To access the memory address of a variable, just use the reference `&` operator before the variable, and the result will represent where the variable is stored:
```C++
int number = 10;
int* myPointer = &number; // Outputs 0x6dfed4
```

### Dereference
However, you can also use the pointer to access and change the value of the variable, by using the operator `*` before the pointer variable (the Dereference operator):
```C++
int test = 10;  // Variable declaration
int* myPointer = &test;    // Pointer declaration

std::cout << myPointer << std::endl; // Outputs 0x6dfed4
std::cout << *myPointer << std::endl; // Outputs 10

*myPointer = 5; // Change test variable to 5

std::cout << test << std::endl; // Outputs 5
std::cout << myPointer << std::endl // Outputs 0x6dfed4
```

### Parameters by Pointers or Reference
In C++, variables are passed to a function by value. When calling a function with an argument, a new variable is instantiated internally and assigned the value passed in the function call. Any modifications to the value inside the function are performed to this new variable; the variable that was invoked with the function call is unchanged.
A function can be written to perform the same task but instead accept a pointer as the argument. This lowers the memory footprint of the program. Unnecessary duplicate variables aren't created. The function can modify the variable's value directly. Any modifications to the variable in the function affect the variable here in this scope too.
```c++
void setValue(int* x) {
    *x = 5;
}

int x = 3;
setValue(&x); // Pass the memory address
std::cout << "The value of x is " << x << ", setValue() modified x." << std::endl;
// Outputs: The value of x is 5, setValue() modified x
```

In C++ (not in C), you can pass a variable by reference by passing in a variable,
and defining the function's parameter like `int& x`. Any modifications to the variable inside the function will also affect the variable here in this scope too.

```c++
void setValue(int& x) {
    x = 5;
}

int x = 3;
setValue( x );
std::cout << "The value of x is " << x << ", setValue() modified x." << std::endl;
// Outputs: The value of x is 5, setValue() modified x
```

### Pointers and Classes
Objects can also be pointed to by pointers: Once declared, a class becomes a valid type, so it can be used as the type pointed to by a pointer. Similarly as with plain data structures, the members of an object can be accessed directly from a pointer by using the arrow operator (`->`).


## C++ keywords

### `extern`
The `extern` keyword specifies that a variable, function, or template is defined somewhere else.

### `auto`
The `auto` keyword tells the compiler to define by itself the variable type when its created.


## Preprocessor derictives
Preprocessor directives are lines included in the code of programs preceded by a hash sign (#). These lines are not program statements but directives for the preprocessor. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements.

### Source file inclusion
With `#include` you specify which file do you want to include and the preprocessor opens that file, read all of its content and just paste it into the file where you wrote your `#include` statement.

### Macro definitions
To define preprocessor macros we can use `#define`. Its syntax is:
```C++
#define identifier replacement
```
When the preprocessor encounters this directive, it replaces any occurrence of identifier in the rest of the code by replacement. This replacement can be an expression, a statement, a block or simply anything. The preprocessor does not understand C++ proper, it simply replaces any occurrence of identifier by replacement. A macro lasts until it is undefined with the `#undef` preprocessor directive.

### Conditional inclusions
These directives allow to include or discard part of the code of a program if a certain condition is met.

- `#ifdef` allows a section of a program to be compiled only if the macro that is specified as the parameter has been defined, no matter which its value is.
- `#ifndef` serves for the exact opposite: the code between `#ifndef` and `#endif` directives is only compiled if the specified identifier has not been previously defined.
- The `#if`, `#else` and `#elif` (i.e., "else if") directives serve to specify some condition to be met in order for the portion of code they surround to be compiled. The condition that follows `#if` or `#elif` can only evaluate constant expressions, including macro expressions.

### Error directive
The `#error` directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter.
