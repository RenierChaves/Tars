# C++


## Header files
C++ programs are built in a two-stage process. First, each source file is compiled on its own. The compiler generates intermediate files for each compiled source file. These intermediate files are often called object files -- but they are not to be confused with objects in your code. Once all the files have been individually compiled, it then links all the object files together, which generates the final binary (the program). This is where header files come in. Header files allow you to make the declaration visible to other .cpp files, while keeping the definition in its own .cpp file.


## Reference
A reference variable is a "reference" to an existing variable, and it is created with the `&` operator.
```C++
string food = "Pizza";
string& meal = food;

std::cout << food << std::endl;  // Outputs Pizza
std::cout << meal << std::endl;  // Outputs Pizza
```
When a variable is created in C++, a memory address is assigned to the variable. And when we assign a value to the variable, it is stored in this memory address. To access it, use the `&` operator, and the result will represent where the variable is stored:
```C++
string food = "Pizza";

std::cout << &food; // Outputs 0x6dfed4
```

### Parameters by reference
When a variable is passed by reference, what is passed is no longer a copy, but the variable itself, the variable identified by the function parameter, becomes somehow associated with the argument passed to the function, and any modification on their corresponding local variables within the function are reflected in the variables passed as arguments in the call.

```c++
void setValue(int& x) {
    x = 5;
}

int x = 3;
setValue( x );
std::cout << "The value of x is " << x << ", setValue() modified x." << std::endl;
// Outputs: The value of x is 5, setValue() modified x
```


## Pointers
When a variable is created in C++, a memory address is assigned to the variable. And when we assign a value to the variable, it is stored in this memory address. A pointer, however, is a variable that stores the memory address as its value. A pointer variable points to a data type (like int or string) of the same type and is created with the `*` operator. The address of the variable you're working with is assigned to the pointer. To access the memory address of a variable, just use the reference `&` operator before the variable, and the result will represent where the variable is stored:
```C++
int number = 10;
int* myPointer = &number; // Outputs 0x6dfed4
```

### Dereference
However, you can also use the pointer to access and change the value of the variable, by using the operator `*` before the pointer variable (the Dereference operator):
```C++
int test = 10;  // Variable declaration
int* myPointer = &test;    // Pointer declaration

std::cout << myPointer << std::endl; // Outputs 0x6dfed4
std::cout << *myPointer << std::endl; // Outputs 10

*myPointer = 5; // Change test variable to 5

std::cout << test << std::endl; // Outputs 5
std::cout << myPointer << std::endl // Outputs 0x6dfed4
```

### Parameters by pointers
In C++, variables are passed to a function by value. When calling a function with an argument, a new variable is instantiated internally and assigned the value passed in the function call. Any modifications to the value inside the function are performed to this new variable; the variable that was invoked with the function call is unchanged. A function can be written to perform the same task but instead accept a pointer as the argument. This lowers the memory footprint of the program. Unnecessary duplicate variables aren't created. The function can modify the variable's value directly. Any modifications to the variable in the function affect the variable here in this scope too.
```c++
void setValue(int* x) {
    *x = 5;
}

int x = 3;
setValue(&x); // Pass the memory address
std::cout << "The value of x is " << x << ", setValue() modified x." << std::endl;
// Outputs: The value of x is 5, setValue() modified x
```


## C++ keywords

### `extern`
The `extern` keyword specifies that a variable, function, or template is defined somewhere else.

### `auto`
The `auto` keyword tells the compiler to define by itself the variable type when its created.

### `const`
Variables declared with `const` added become constants and cannot be altered by the program.


## Preprocessor derictives
Preprocessor directives are lines included in the code of programs preceded by a hash sign (#). These lines are not program statements but directives for the preprocessor. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements.

### Source file inclusion
With `#include` you specify which file do you want to include and the preprocessor opens that file, read all of its content and just paste it into the file where you wrote your `#include` statement.

### Macro definitions
To define preprocessor macros we can use `#define`. Its syntax is:
```C++
#define identifier replacement
```
When the preprocessor encounters this directive, it replaces any occurrence of identifier in the rest of the code by replacement. This replacement can be an expression, a statement, a block or simply anything. The preprocessor does not understand C++ proper, it simply replaces any occurrence of identifier by replacement. A macro lasts until it is undefined with the `#undef` preprocessor directive.

### Conditional inclusions
These directives allow to include or discard part of the code of a program if a certain condition is met.

- `#ifdef` allows a section of a program to be compiled only if the macro that is specified as the parameter has been defined, no matter which its value is.
- `#ifndef` serves for the exact opposite: the code between `#ifndef` and `#endif` directives is only compiled if the specified identifier has not been previously defined.
- The `#if`, `#else` and `#elif` (i.e., "else if") directives serve to specify some condition to be met in order for the portion of code they surround to be compiled. The condition that follows `#if` or `#elif` can only evaluate constant expressions, including macro expressions.

### Error directive
The `#error` directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter.


## Classes
Classes are an expanded concept of data structures: like data structures, they can contain data members, but they can also contain functions as members. An object is an instantiation of a class. In terms of variables, a class would be the type, and an object would be the variable. To create a class, use the `class` keyword:
```C++
class MyClass {            // The class
public:                    // Access specifier
    int myNum;             // Attribute (int variable)
    std::string myString;  // Attribute (string variable)
};
```

### Access specifier
Classes have the same format as plain data structures, except that they can also include member functions and have these new things called access specifiers. An access specifier is one of the following three keywords: private, public or protected. These specifiers modify the access rights for the members that follow them:
- `public` - members are accessible from outside the class
- `private` - members cannot be accessed (or viewed) from outside the class
- `protected` - members cannot be accessed from outside the class, however, they can be accessed in inherited classes.

### Member function
Member functions are functions that belongs to the class. There are two ways to define functions that belongs to a class:
- Inside class definition
```C++
class MyClass {                 // The class
public:                         // Access specifier
    void MemberFunction() {     // Member function defined inside the class
        std::cout << "Hello World!";
    }
};
```
- Outside class definition
```C++
class MyClass {                 // The class
public:                         // Access specifier
    void MemberFunction();      // Member function declaration
};

// Member function definition outside the class
void MyClass::MemberFunction() {
    std::cout << "Hello World!";
}
```

### Constructor
A class can include a special member function called its **constructor**, which is automatically called whenever a new object of this class is created, allowing the class to initialize member variables or allocate storage. This constructor function is declared just like a regular member function, but with a name that matches the class name and without any return type; not even `void`.
```C++
class Person {
public:
    Person(int age, const char* name) {
        m_Age = age;
        m_Name = name;
    }
private:
    m_Age;
    m_Name;
};
```

### Pointers and classes
Objects can also be pointed to by pointers: Once declared, a class becomes a valid type, so it can be used as the type pointed to by a pointer. Similarly as with plain data structures, the members of an object can be accessed directly from a pointer by using the arrow operator (`->`).

### Objects and member functions `const`
`const` objects are limited to access only member functions marked as `const`. Declaring a member function with the `const` keyword specifies that the function is a "read-only" function that does not modify the object for which it is called. A constant member function can only modify static data members and call only other constant member functions. Note that `const` can be used to qualify the type returned by a member function. This `const` is not the same as the one which specifies a member as `const`. Both are independent and are located at different places in the function declaration:
```C++
int get() const {return x;}         // Const member function
const int get() {return x;}         // Member function returning a const
const int get() const {return x;}   // Const member function returning a const
```